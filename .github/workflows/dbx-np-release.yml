name: "dbx-np-release"

# on:
#   workflow_dispatch:
#     inputs:
#       release_type:
#         type: choice
#         options:
#         - MAJOR
#         - MINOR
#         description: 'Type of version you want to Release'
#         required: true
on:
  workflow_dispatch:
    inputs:
      branch_name:
        description: 'Branch to run the workflow on'
        required: true
        default: 'main' # Or your default branch
        type: string        
       

jobs:

  deploy-databricks-to-qa:
    if: startsWith(github.ref_name, 'release/')  
    runs-on: ubuntu-latest
    name: "Deploy Databricks Assets to QA from release branch"
    environment: QA
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3       
      
      - name: Install Databricks CLI
        if: success()
        uses: databricks/setup-cli@main

      - name: Validate the bundle on QA
        if: success()
        run: databricks bundle validate -t qa
        env:
          DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}

      - name: Deploy the bundle on QA
        if: success()
        run: databricks bundle deploy -t qa --force-lock
        env:
          DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}

      - name: Create pull request
        uses: thomaseizinger/create-pull-request@1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          head: ${{ github.event.inputs.branch_name }}
          base: main
          title: Release version ${{ github.event.inputs.branch_name }}
          reviewers: ${{ github.actor }} 
          body: |
            Hi @${{ github.actor }}!

            This PR was created in response to a manual trigger of the release workflow here: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}.
            Merging this PR will create a GitHub release and upload any assets that are created as part of the release build.

  deploy-databricks-to-prod:
    if: startsWith(github.ref, 'refs/heads/main')
    runs-on: ubuntu-latest     
    name: "Deploy Databricks Assets to PROD from main branch"
    environment: PROD
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3       
      
      - name: Install Databricks CLI
        if: success()
        uses: databricks/setup-cli@main

      - name: Validate the bundle on PROD
        if: success()
        run: databricks bundle validate -t prod
        env:
          DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}

      - name: Deploy the bundle on PROD
        if: success()
        run: databricks bundle deploy -t prod --force-lock
        env:
          DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}

  release:
    needs: deploy-databricks-to-prod
    runs-on: ubuntu-latest   
    steps:
      - name: Checkout code
        if: success()
        uses: actions/checkout@v4  
        
      - name: Extract version from branch name (for release branches)
        if: startsWith(github.event.pull_request.head.ref, 'release/')
        run: |
          BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
          VERSION=${BRANCH_NAME#release/}
          echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV

      # - name: Extract version from branch name (for hotfix branches)
      #   if: startsWith(github.event.pull_request.head.ref, 'hotfix/')
      #   run: |
      #     BRANCH_NAME="${{ github.event.pull_request.head.ref }}"
      #     VERSION=${BRANCH_NAME#hotfix/}
      #     echo "RELEASE_VERSION=$VERSION" >> $GITHUB_ENV

      - name: Create Release
        uses: thomaseizinger/create-release@1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          target_commitish: ${{ github.event.pull_request.merge_commit_sha }}
          tag_name: ${{ env.RELEASE_VERSION }}
          name: ${{ env.RELEASE_VERSION }}
          draft: false
          prerelease: false

      - name: Checkout develop branch
        uses: actions/checkout@v4
        with:
          ref: develop
          fetch-depth: 0  # Fetch all history for accurate diff

      - name: Check for file changes between main and develop
        run: |
          git fetch origin main
          CHANGED_FILES=$(git diff --name-only origin/main develop)
          if [ -n "$CHANGED_FILES" ]; then
            echo "FILES_CHANGED=true" >> $GITHUB_ENV
          else
            echo "FILES_CHANGED=false" >> $GITHUB_ENV
          fi

      - name: Merge main into develop branch (for release branches)
        if: startsWith(github.event.pull_request.head.ref, 'release/') && env.FILES_CHANGED == 'true'
        uses: thomaseizinger/create-pull-request@1.0.0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          head: main
          base: develop
          title: Merge main into develop branch
          body: |
            This PR merges the main branch back into develop.
            This ensures that the updates that happened on the release branch are also present on the develop branch.

      # - name: Merge main into develop branch (for hotfix branches)
      #   if: startsWith(github.event.pull_request.head.ref, 'hotfix/') && env.FILES_CHANGED == 'true'
      #   uses: thomaseizinger/create-pull-request@1.0.0
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     head: main
      #     base: develop
      #     title: Merge main into develop branch
      #     body: |
      #       This PR merges the main branch back into develop.
      #       This ensures that the updates that happened on the hotfix branch are also present on the develop branch.