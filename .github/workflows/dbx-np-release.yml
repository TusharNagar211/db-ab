name: "Databricks Asset Bundle CI/Cd"


# on:
#   workflow_dispatch:
#     inputs:
#       release_type:
#         type: choice
#         options:
#         - MAJOR
#         - MINOR
#         description: 'Type of version you want to Release'
#         required: true
on:
  push:
    branches:
      - main
      - develop
      - 'release/**'

  # workflow_dispatch:
  #   inputs:
  #     branch_name:
  #       description: 'Branch to run the workflow on'
  #       required: true
  #       default: 'main' # Or your default branch
  #       type: string
  #     release_type:
  #       type: choice
  #       options:
  #       - MAJOR
  #       - MINOR
  #       description: 'Type of version you want to Release'
  #       required: true              

permissions:
  id-token: write
  contents: read

jobs:
  deploy-databricks-to-dev:
    if: startsWith(github.ref_name, 'develop')  
    runs-on: ubuntu-latest
    name: "Deploy Databricks Assets to DEV from develop branch"
    environment: QA
    env:
      DATABRICKS_AUTH_TYPE: github-oidc
      DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
      DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3       
      
      - name: Install Databricks CLI
        if: success()
        uses: databricks/setup-cli@main


      - name: Validate the bundle on DEV
        if: success()
        run: databricks bundle validate -t dev
        env:
          DATABRICKS_AUTH_TYPE: github-oidc
          DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
          DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea      
          ACTIONS_ID_TOKEN_REQUEST_URL: ${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}
          ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ env.ACTIONS_ID_TOKEN_REQUEST_TOKEN }}        

      - name: Deploy the bundle on DEV
        if: success()
        run: databricks bundle deploy -t dev --force-lock
        env:
          DATABRICKS_AUTH_TYPE: github-oidc
          DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
          DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea  

  deploy-databricks-to-qa:
    if: startsWith(github.ref_name, 'release/')  
    runs-on: ubuntu-latest
    name: "Deploy Databricks Assets to QA from release branch"
    environment: QA
    env:
      DATABRICKS_AUTH_TYPE: github-oidc
      DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
      DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3       
      
      - name: Install Databricks CLI
        if: success()
        uses: databricks/setup-cli@main

      - name: Validate the bundle on QA
        if: success()
        run: databricks bundle validate -t qa
        env:
          # DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          # DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          # DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}
          DATABRICKS_AUTH_TYPE: github-oidc
          DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
          DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea      
          ACTIONS_ID_TOKEN_REQUEST_URL: ${{ env.ACTIONS_ID_TOKEN_REQUEST_URL }}
          ACTIONS_ID_TOKEN_REQUEST_TOKEN: ${{ env.ACTIONS_ID_TOKEN_REQUEST_TOKEN }}        

      - name: Deploy the bundle on QA
        if: success()
        run: databricks bundle deploy -t qa --force-lock
        env:
          # DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          # DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          # DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}
          DATABRICKS_AUTH_TYPE: github-oidc
          DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
          DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea  

      # - name: Create pull request
      #   uses: thomaseizinger/create-pull-request@1.0.0
      #   env:
      #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      #   with:
      #     head: ${{ github.event.inputs.branch_name }}
      #     base: main
      #     title: Release version ${{ github.event.inputs.branch_name }}
      #     reviewers: ${{ github.actor }} 
      #     body: |
      #       Hi @${{ github.actor }}!

      #       This PR was created in response to a manual trigger of the release workflow here: https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}.
      #       Merging this PR will create a GitHub release and upload any assets that are created as part of the release build.


  deploy-databricks-to-prod:
    if: startsWith(github.ref, 'refs/heads/main')
    runs-on: ubuntu-latest     
    name: "Deploy Databricks Assets to PROD from main branch"
    environment: QA
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v3       
      
      - name: Install Databricks CLI
        if: success()
        uses: databricks/setup-cli@main

      - name: Validate the bundle on PROD
        if: success()
        run: databricks bundle validate -t prod
        env:
          # DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          # DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          # DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}
          DATABRICKS_AUTH_TYPE: github-oidc
          DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
          DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea  

      - name: Deploy the bundle on PROD
        if: success()
        run: databricks bundle deploy -t prod --force-lock
        env:
          # DATABRICKS_HOST: ${{ secrets.DATABRICKS_HOST_URL }}
          # DATABRICKS_CLIENT_ID: ${{ secrets.DATABRICKS_SP_CLIENT_ID }}
          # DATABRICKS_CLIENT_SECRET: ${{ secrets.DATABRICKS_SP_SECRET }}
          DATABRICKS_AUTH_TYPE: github-oidc
          DATABRICKS_HOST: https://adb-4091704180100433.13.azuredatabricks.net/
          DATABRICKS_CLIENT_ID: 8bd9e9cd-2910-4014-8321-94b1f9ce73ea  

  semantic-release:
    name: 'Tag & Release'
    runs-on: ubuntu-latest
    needs: deploy-databricks-to-prod

    permissions:
      contents: write  # Needed to create Git tags/releases

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install semantic-release and plugins
        run: |
          npm install --global semantic-release \
            @semantic-release/changelog \
            @semantic-release/git \
            @semantic-release/exec \
            @semantic-release/commit-analyzer \
            @semantic-release/release-notes-generator
            @semantic-release/github

      - name: Run semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: semantic-release

  # release:
  #   needs: deploy-databricks-to-prod
  #   runs-on: ubuntu-latest   
  #   steps:
  #     - name: Checkout code
  #       if: success()
  #       uses: actions/checkout@v4  

  #     - name: Get latest release
  #       id: latest_release
  #       run: |
  #         RESPONSE=$(curl -H "Authorization: token ${{ secrets.GITHUB_TOKEN }}" \
  #         --silent "https://api.github.com/repos/${{ github.repository }}/releases/latest")
  #         echo "Response: $RESPONSE"
  #         LATEST_RELEASE=$(echo "$RESPONSE" | jq -r .tag_name)
  #         echo "version=$LATEST_RELEASE" >> $GITHUB_OUTPUT
  #       shell: bash
      
  #     - name: Increment Release version
  #       id: increment_version
  #       run: |
  #         RELEASE_TYPE=${{ github.event.inputs.release_type }}
  #         VERSION=${{ steps.latest_release.outputs.version }}
  #         MAJOR=$(echo $VERSION | cut -d. -f1)
  #         MINOR=$(echo $VERSION | cut -d. -f2)
  #         PATCH=$(echo $VERSION | cut -d. -f3)
  #         if [[ (-z "$VERSION" || "$VERSION" == "null") && "$RELEASE_TYPE" = "MAJOR" ]]; then
  #           NEW_VERSION="1.0.0"
  #         elif [[ (-z "$VERSION" || "$VERSION" == "null") && "$RELEASE_TYPE" = "MINOR" ]]; then
  #           NEW_VERSION="0.1.0"
  #         elif [[ -n "$VERSION" && "$RELEASE_TYPE" = "MAJOR" ]]; then
  #           NEW_MAJOR=$((MAJOR + 1))
  #           NEW_MINOR="0"
  #           NEW_PATCH="0"
  #           NEW_VERSION="$NEW_MAJOR.$NEW_MINOR.$NEW_PATCH"
  #         elif [[ -n "$VERSION" && "$RELEASE_TYPE" = "MINOR" ]]; then
  #           NEW_MINOR=$((MINOR + 1))
  #           NEW_PATCH="0"
  #           NEW_VERSION="$MAJOR.$NEW_MINOR.$NEW_PATCH"
  #         fi
  #         echo "The new Release version is $NEW_VERSION"
  #         echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
  #       shell: bash

  #     - name: Create Release
  #       uses: thomaseizinger/create-release@1.0.0
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       with:
  #         # target_commitish: ${{ github.event.pull_request.merge_commit_sha }}
  #         tag_name: ${{ steps.increment_version.outputs.new_version }}
  #         name: ${{ steps.increment_version.outputs.new_version }}
  #         draft: false
  #         prerelease: false

  #     - name: Checkout develop branch
  #       uses: actions/checkout@v4
  #       with:
  #         ref: develop
  #         fetch-depth: 0  # Fetch all history for accurate diff

  #     - name: Check for file changes between main and develop
  #       run: |
  #         git fetch origin main
  #         CHANGED_FILES=$(git diff --name-only origin/main develop)
  #         if [ -n "$CHANGED_FILES" ]; then
  #           echo "FILES_CHANGED=true" >> $GITHUB_ENV
  #         else
  #           echo "FILES_CHANGED=false" >> $GITHUB_ENV
  #         fi

  #     - name: Merge main into develop branch (for release branches)
  #       if: startsWith(github.event.pull_request.head.ref, 'release/') && env.FILES_CHANGED == 'true'
  #       uses: thomaseizinger/create-pull-request@1.0.0
  #       env:
  #         GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #       with:
  #         head: main
  #         base: develop
  #         title: Merge main into develop branch
  #         body: |
  #           This PR merges the main branch back into develop.
  #           This ensures that the updates that happened on the release branch are also present on the develop branch.

  #     # - name: Merge main into develop branch (for hotfix branches)
  #     #   if: startsWith(github.event.pull_request.head.ref, 'hotfix/') && env.FILES_CHANGED == 'true'
  #     #   uses: thomaseizinger/create-pull-request@1.0.0
  #     #   env:
  #     #     GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
  #     #   with:
  #     #     head: main
  #     #     base: develop
  #     #     title: Merge main into develop branch
  #     #     body: |
  #     #       This PR merges the main branch back into develop.
  #     #       This ensures that the updates that happened on the hotfix branch are also present on the develop branch.